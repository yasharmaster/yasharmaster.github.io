<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <title>Creating Match, Return, Order By clauses From a PathTree</title>
    <meta name="description" content="In this post I’ll describe in detail, how I created Match, Return and Order By clauses of Cypher using a PathTree. PathTree was discussed in the previous post.">

    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="http://yasharmaster.github.io/blog/2017/creating-match-return-order-by-from-pathtree/">
    <link rel="alternate" type="application/rss+xml" title="Yash Sharma" href="http://yasharmaster.github.io/feed.xml" />
    <script src="http://fast.eager.io/ehZJ0e6K5k.js"></script>
  </head>

  <!-- Begin Jekyll SEO tag v2.0.0 -->
<title>Creating Match, Return, Order By clauses From a PathTree - Yash Sharma</title>
<meta property="og:title" content="Creating Match, Return, Order By clauses From a PathTree" />
<meta name="description" content="In this post I’ll describe in detail, how I created Match, Return and Order By clauses of Cypher using a PathTree. PathTree was discussed in the previous post." />
<meta property="og:description" content="In this post I’ll describe in detail, how I created Match, Return and Order By clauses of Cypher using a PathTree. PathTree was discussed in the previous post." />
<link rel="canonical" href="http://yasharmaster.github.io/blog/2017/creating-match-return-order-by-from-pathtree/" />
<meta property="og:url" content="http://yasharmaster.github.io/blog/2017/creating-match-return-order-by-from-pathtree/" />
<meta property="og:site_name" content="Yash Sharma" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-07-02T13:30:00+05:30" />
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "Creating Match, Return, Order By clauses From a PathTree",
    "datePublished": "2017-07-02T13:30:00+05:30",
    "description": "In this post I’ll describe in detail, how I created Match, Return and Order By clauses of Cypher using a PathTree. PathTree was discussed in the previous post.",
    "url": "http://yasharmaster.github.io/blog/2017/creating-match-return-order-by-from-pathtree/"
  }
</script>
<!-- End Jekyll SEO tag -->
  <body>
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', '', 'auto');
  ga('send', 'pageview');
</script>

    <main>
      <header class="site-header">
  <div class="container">
    <h1><a href="/">Yash <span>Sharma</span></a></h1>

    <button type="button" class="sliding-panel-button">
      <span></span>
      <span></span>
      <span></span>
    </button>

    <nav class="navbar sliding-panel-content">
      <ul>
        
          <li><a href="/about" title="About">About</a></li>
        
          <li><a href="/resume" title="Resume">Resume</a></li>
        
          <li><a href="/blog" title="Blog">Blog</a></li>
        
        <li><a href="/feed.xml" target="_blank"><i class="icon icon-feed"></i></a></li>
      </ul>
    </nav>
  </div>
</header>

<div class="sliding-panel-fade-screen"></div>


      <div class="container">
        <article role="article" class="post">

  <div class="card">
    <header class="post-header">
      <h1 class="post-title">Creating Match, Return, Order By clauses From a PathTree</h1>
      <p class="post-meta">Jul 2, 2017</p>
    </header>

    <div class="post-content">
      <p>In this post I’ll describe in detail, how I created Match, Return and Order By clauses of Cypher using a PathTree. PathTree was discussed in the <a href="/blog/2017/path-query-cypher-puzzle-part-2/">previous post</a>.</p>

<h2 id="description-of-clauses">Description of Clauses</h2>

<h3 id="match">Match</h3>

<p>Match is the very first clause in every Cypher query. It allows you to specify the patterns Neo4j will search for in the database. These patterns must be such that the data which matches them, must be the data you wish to operate (or query) on. Consider an example Match clause which matches three <em>Genes</em> such that two of them  <em>INTERACTS_WITH</em> the third one.</p>

<figure class="highlight"><pre><code class="language-cypher" data-lang="cypher"><span class="k">MATCH</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="n">Gene</span><span class="p">)</span><span class="o">-[</span><span class="p">:</span><span class="n">INTERACTS_WITH</span><span class="o">]-&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">:</span><span class="n">Gene</span><span class="p">)</span><span class="o">&lt;-[</span><span class="p">:</span><span class="n">INTERACTS_WITH</span><span class="o">]-</span><span class="p">(</span><span class="n">c</span><span class="p">:</span><span class="n">Gene</span><span class="p">)</span><span class="w"></span></code></pre></figure>

<p>The pattern above is a 2-dimensional pattern which we often have to deal with, in Cypher. Although, it is easier to imagine the pattern in 2-D, we generally need to break them down into multiple 1-D patterns while writing cypher queries. Also, 1-D patterns would be easier to generate programmatically than their 2-D counterparts. For example, the following Match clause with two 1-D patterns is equivalent to the one shown above.</p>

<figure class="highlight"><pre><code class="language-cypher" data-lang="cypher"><span class="k">MATCH</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="n">Gene</span><span class="p">)</span><span class="o">-[</span><span class="p">:</span><span class="n">INTERACTS_WITH</span><span class="o">]-&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">:</span><span class="n">Gene</span><span class="p">),</span><span class="w"></span>
<span class="p">(</span><span class="n">c</span><span class="p">:</span><span class="n">Gene</span><span class="p">)</span><span class="o">-[</span><span class="p">:</span><span class="n">INTERACTS_WITH</span><span class="o">]-&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="w"></span></code></pre></figure>

<p>Note that we could simply use the variable name <code>b</code> in the second pattern without specifying the Label <em>Gene</em>. It doesn’t seem very significant here but it makes generating queries very convinient while dealing with some complicated paths. Suppose you need to specify a Path/Node/Relationship again and again in the query, wouldn’t you be comfortable in just writing its variable name and get done with it?</p>

<h3 id="return">Return</h3>

<p>In the RETURN part of the cypher query, we define the parts of the pattern in which we are interested. It can be nodes, relationships, or properties on these.</p>

<figure class="highlight"><pre><code class="language-cypher" data-lang="cypher"><span class="k">MATCH</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="n">Gene</span><span class="w"> </span><span class="p">{</span><span class="n">primaryIdentifier</span><span class="p">:</span><span class="err">&#39;</span><span class="n">WBGene00007063</span><span class="err">&#39;</span><span class="p">})</span><span class="o">-[</span><span class="n">r</span><span class="p">:</span><span class="n">INTERACTS_WITH</span><span class="o">]-&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">:</span><span class="n">Gene</span><span class="p">)</span><span class="w"></span>
<span class="c1">// Following are some possbile return statements,</span>
<span class="k">RETURN</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="k">RETURN</span><span class="w"> </span><span class="n">r</span><span class="w"></span>
<span class="k">RETURN</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">primaryIdentifier</span><span class="w"></span>
<span class="k">RETURN</span><span class="w"> </span><span class="n">r</span><span class="p">.</span><span class="n">dataSet</span><span class="w"></span></code></pre></figure>

<h3 id="order-by">Order By</h3>

<p>ORDER BY is a sub-clause following RETURN, and it specifies that the output should be sorted and how. For example,</p>

<figure class="highlight"><pre><code class="language-cypher" data-lang="cypher"><span class="k">MATCH</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="n">Gene</span><span class="w"> </span><span class="p">{</span><span class="n">primaryIdentifier</span><span class="p">:</span><span class="err">&#39;</span><span class="n">WBGene00007063</span><span class="err">&#39;</span><span class="p">})</span><span class="o">-[</span><span class="n">r</span><span class="p">:</span><span class="n">INTERACTS_WITH</span><span class="o">]-&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">:</span><span class="n">Gene</span><span class="p">)</span><span class="w"></span>
<span class="k">RETURN</span><span class="w"> </span><span class="n">b</span><span class="w"></span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">symbol</span><span class="w"></span></code></pre></figure>

<h2 id="assigning-variable-names-to-treenodes">Assigning variable names to TreeNodes</h2>

<p>We see that variable names are crucial in a Cypher query. A PathTree represents all the paths in the corresponding PathQuery. Since we can have a constraint/view/order on any path, therefore we need to assign variable name to each node of the PathTree.</p>

<p><img src="/images/PathTree.png" alt="A Path Tree" /></p>

<p>We cannot just use the component name as the variable name. This is because a component can be repeated in the same path. For example, in <code>Gene.chromosome.gene.length</code>, <code>gene</code> appears twice. Having a unique variable name for each TreeNode is crucial to generating the Cypher query.</p>

<p>To create the variable names, I have simply separated components in the path using an underscore instead of a dot. Also, I have converted the path string to its lower case form. For example, the TreeNode for the path <code>Gene.homologues.dataSets.name</code> will have variable name <code>gene_homologues_datasets_name</code>. This approach is fine till we don’t exceed the max length of variable name for a path.</p>

<h2 id="clause-creation">Clause Creation</h2>

<h4 id="some-background">Some background</h4>

<p>A TreeNode for the path <code>Gene.chromosome.gene.length</code>, stores the following information.</p>

<ul>
  <li><code>name</code> : The last component of the path, i.e. length.</li>
  <li><code>variable name</code> : The one we generated using approach shown above, i.e. gene_chromosome_gene_length.</li>
  <li><code>graphical name</code> : This is the name by which we refer this entity/property in the InterMine Neo4j graph. Here we keep it same as <code>name</code>, i.e. length.</li>
</ul>

<h4 id="return-1">RETURN</h4>

<p>The return clause always starts with the <em>RETURN</em> keyword. After that, we simply append the variable name and the respective graphical name for each <code>View's</code> path of the PathQuery.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">createReturnClause</span><span class="o">(</span><span class="n">Query</span> <span class="n">query</span><span class="o">,</span> <span class="n">PathTree</span> <span class="n">pathTree</span><span class="o">,</span> <span class="n">PathQuery</span> <span class="n">pathQuery</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">path</span> <span class="o">:</span> <span class="n">pathQuery</span><span class="o">.</span><span class="na">getView</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">TreeNode</span> <span class="n">treeNode</span> <span class="o">=</span> <span class="n">pathTree</span><span class="o">.</span><span class="na">getTreeNode</span><span class="o">(</span><span class="n">path</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">treeNode</span><span class="o">.</span><span class="na">getTreeNodeType</span><span class="o">()</span> <span class="o">==</span> <span class="n">TreeNodeType</span><span class="o">.</span><span class="na">PROPERTY</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Return ONLY IF a property is queried !!</span>
            <span class="n">query</span><span class="o">.</span><span class="na">addToReturn</span><span class="o">(</span><span class="n">treeNode</span><span class="o">.</span><span class="na">getParent</span><span class="o">().</span><span class="na">getVariableName</span><span class="o">()</span> <span class="o">+</span> 
        					<span class="s">&quot;.&quot;</span> <span class="o">+</span> 
        					<span class="n">treeNode</span><span class="o">.</span><span class="na">getGraphicalName</span><span class="o">());</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h4 id="order-by-1">ORDER BY</h4>

<p>The order by clause always starts with the <em>ORDER BY</em> keyword. After that, we simply append the variable name and the respective graphical name for each <code>sortOrder's</code> path of the PathQuery. Also, the sort type (Ascending/Descending) is also added.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="c1">// The method that creates the order by clause</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">createOrderByClause</span><span class="o">(</span><span class="n">Query</span> <span class="n">query</span><span class="o">,</span> <span class="n">PathTree</span> <span class="n">pathTree</span><span class="o">,</span> <span class="n">PathQuery</span> <span class="n">pathQuery</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">OrderElement</span><span class="o">&gt;</span> <span class="n">orderElements</span> <span class="o">=</span> <span class="n">pathQuery</span><span class="o">.</span><span class="na">getOrderBy</span><span class="o">();</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">OrderElement</span> <span class="n">orderElement</span> <span class="o">:</span> <span class="n">orderElements</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Order</span><span class="o">(</span><span class="n">orderElement</span><span class="o">,</span> <span class="n">pathTree</span><span class="o">);</span>
        <span class="n">query</span><span class="o">.</span><span class="na">addToOrderBy</span><span class="o">(</span><span class="n">order</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Constructor of the order class</span>
<span class="n">Order</span><span class="o">(</span><span class="n">OrderElement</span> <span class="n">orderElement</span><span class="o">,</span> <span class="n">PathTree</span> <span class="n">pathTree</span><span class="o">){</span>
    <span class="n">TreeNode</span> <span class="n">treeNode</span> <span class="o">=</span> <span class="n">pathTree</span><span class="o">.</span><span class="na">getTreeNode</span><span class="o">(</span><span class="n">orderElement</span><span class="o">.</span><span class="na">getOrderPath</span><span class="o">());</span>
    <span class="n">propertyKey</span> <span class="o">=</span> <span class="n">treeNode</span><span class="o">.</span><span class="na">getGraphicalName</span><span class="o">();</span>
    <span class="c1">// Store variableName of parent TreeNode</span>
    <span class="n">variableName</span> <span class="o">=</span> <span class="n">treeNode</span><span class="o">.</span><span class="na">getParent</span><span class="o">().</span><span class="na">getVariableName</span><span class="o">();</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="n">orderElement</span><span class="o">.</span><span class="na">getDirection</span><span class="o">().</span><span class="na">toString</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// String representation of the order class object</span>
<span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">variableName</span> <span class="o">+</span> <span class="s">&quot;.&quot;</span> <span class="o">+</span>
            <span class="n">propertyKey</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span>
            <span class="n">direction</span><span class="o">;</span>
<span class="o">}</span></code></pre></figure>

<h4 id="match-1">Match</h4>

<p>Creation of Match clause is rather complex. The match clause always starts with the <em>MATCH</em> keyword. After that, for each edge in the PathTree we write two nodes and the relationship between them. If two adjacent TreeNodes represent Graph Nodes, then we use a dummy relationship to join them. Otherwise we add the relationship represented by the TreeNode in between.</p>

<p>The <code>createMatchClause()</code> recursive method takes in the <code>Query</code> object and the root <code>TreeNode</code> as parameters. The following code snippet shows the method in action.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">createMatchClause</span><span class="o">(</span><span class="n">Query</span> <span class="n">query</span><span class="o">,</span> <span class="n">TreeNode</span> <span class="n">treeNode</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">treeNode</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">treeNode</span><span class="o">.</span><span class="na">getParent</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Root TreeNode is always a Graph Node</span>
        <span class="n">query</span><span class="o">.</span><span class="na">addToMatch</span><span class="o">(</span><span class="s">&quot;(&quot;</span> <span class="o">+</span> <span class="n">treeNode</span><span class="o">.</span><span class="na">getVariableName</span><span class="o">()</span> <span class="o">+</span>
                         <span class="s">&quot; :&quot;</span> <span class="o">+</span> <span class="n">treeNode</span><span class="o">.</span><span class="na">getGraphicalName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot;)&quot;</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">treeNode</span><span class="o">.</span><span class="na">getTreeNodeType</span><span class="o">()</span> <span class="o">==</span> <span class="n">TreeNodeType</span><span class="o">.</span><span class="na">NODE</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">treeNode</span><span class="o">.</span><span class="na">getParent</span><span class="o">().</span><span class="na">getTreeNodeType</span><span class="o">()</span> <span class="o">==</span> <span class="n">TreeNodeType</span><span class="o">.</span><span class="na">NODE</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// If current TreeNode is a Graph Node and its parent is also a Graph Node,</span>
            <span class="c1">// then add a dummy relationship.</span>
            <span class="n">query</span><span class="o">.</span><span class="na">addToMatch</span><span class="o">(</span><span class="s">&quot;(&quot;</span> <span class="o">+</span> <span class="n">treeNode</span><span class="o">.</span><span class="na">getParent</span><span class="o">().</span><span class="na">getVariableName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot;)&quot;</span> <span class="o">+</span>
                            <span class="s">&quot;-[]-(&quot;</span> <span class="o">+</span> <span class="n">treeNode</span><span class="o">.</span><span class="na">getVariableName</span><span class="o">()</span> <span class="o">+</span>
                            <span class="s">&quot; :&quot;</span> <span class="o">+</span> <span class="n">treeNode</span><span class="o">.</span><span class="na">getGraphicalName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot;)&quot;</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">treeNode</span><span class="o">.</span><span class="na">getParent</span><span class="o">().</span><span class="na">getTreeNodeType</span><span class="o">()</span> <span class="o">==</span> <span class="n">TreeNodeType</span><span class="o">.</span><span class="na">RELATIONSHIP</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// If current TreeNode is a Graph Node and its parent is a Graph Relationship,</span>
            <span class="c1">// then match an actual relationship of the current node with its grand parent node.</span>
            <span class="n">query</span><span class="o">.</span><span class="na">addToMatch</span><span class="o">(</span><span class="s">&quot;(&quot;</span> <span class="o">+</span> <span class="n">treeNode</span><span class="o">.</span><span class="na">getParent</span><span class="o">().</span><span class="na">getParent</span><span class="o">().</span><span class="na">getVariableName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot;)&quot;</span> <span class="o">+</span>
                            <span class="s">&quot;-[&quot;</span> <span class="o">+</span> <span class="n">treeNode</span><span class="o">.</span><span class="na">getParent</span><span class="o">().</span><span class="na">getVariableName</span><span class="o">()</span> <span class="o">+</span>
                            <span class="s">&quot;:&quot;</span> <span class="o">+</span> <span class="n">treeNode</span><span class="o">.</span><span class="na">getParent</span><span class="o">().</span><span class="na">getGraphicalName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot;]&quot;</span> <span class="o">+</span>
                            <span class="s">&quot;-(&quot;</span> <span class="o">+</span> <span class="n">treeNode</span><span class="o">.</span><span class="na">getVariableName</span><span class="o">()</span> <span class="o">+</span>
                            <span class="s">&quot; :&quot;</span> <span class="o">+</span> <span class="n">treeNode</span><span class="o">.</span><span class="na">getGraphicalName</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot;)&quot;</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// If current TreeNode represents a Graphical Relationship, then Do nothing.</span>
    <span class="c1">// We will match this relationship when recursion reaches its children.</span>

    <span class="c1">// Add all children to Match clause</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">String</span> <span class="n">key</span> <span class="o">:</span> <span class="n">treeNode</span><span class="o">.</span><span class="na">getChildrenKeys</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">createMatchClause</span><span class="o">(</span><span class="n">query</span><span class="o">,</span> <span class="n">treeNode</span><span class="o">.</span><span class="na">getChild</span><span class="o">(</span><span class="n">key</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>In the next post I’ll cover how we create the <a href="http://neo4j.com/docs/developer-manual/current/cypher/clauses/where/">Where</a> clause which is most complex among all the clauses.</p>

    </div>

    
<hr>

<aside id="comments" class="disqus">
  <div class="container">
    <h3><i class="icon icon-comments-o"></i> Comments</h3>
    <div id="disqus_thread"></div>
    <script>
      var disqus_config = function() {
        this.page.url = 'http://yasharmaster.github.io';
        this.page.identifier = '/blog/2017/creating-match-return-order-by-from-pathtree';
      };
      (function() {
        var d = document,
        s = d.createElement('script');
        s.src = '//www-yashsharma-tech.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
  </div>
</aside>

  </div>

</article>

      </div>

      <footer class="site-footer">
  <div class="container">
    <ul class="social">
  <li><a href="http://github.com/yasharmaster" target="_blank"><i class="icon icon-github"></i></a></li>
  <li><a href="http://twitter.com/yashsharma260" target="_blank"><i class="icon icon-twitter"></i></a></li>
  <li><a href="http://facebook.com/yasharma.95" target="_blank"><i class="icon icon-facebook"></i></a></li>
  <li><a href="http://linkedin.com/in/yash-sharma-317367b9" target="_blank"><i class="icon icon-linkedin"></i></a></li>
</ul>
    <p class="txt-medium-gray">
      <small>&copy;2017 Yash Sharma. All rights reserved. Made with <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> and ♥</small>
    </p>
  </div>
</footer>


      <a href="http://github.com/yasharmaster/yasharmaster.github.io" target="_blank" class="github-corner"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#337ab7; color:#fff; position: absolute; top: 0; border: 0; right: 0;"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

      <script src="//code.jquery.com/jquery-1.11.3.min.js"></script>
      <script>
      $(document).ready(function() {
        $('.sliding-panel-button,.sliding-panel-fade-screen,.sliding-panel-close').on('click touchstart',function (e) {
          $('.sliding-panel-content,.sliding-panel-fade-screen').toggleClass('is-visible');
          e.preventDefault();
        });
      });
      </script>
    </main>
  </body>
</html>
